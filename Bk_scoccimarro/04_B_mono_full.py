import numpy
import time
from nbodykit.lab import *
from nbodykit.source.mesh.catalog import CompensateCIC, CompensateTSC, CompensatePCS
import os
import shutil
from funcs import get_k_dist, listdir
from pmesh import pm
import gc

"""
PARAMETER SETTING
==================================================================
(All inside "***" block)

silent: bool
    Whether or not print some additional information which can be very useful in debugging

low_memory_mode: bool
    Whether or not store binned arrays to disk to save memory. 
    It is highly recommended NOT to use this mode in this full-config measurement because 
    for every config you will need to load 3 ndarrays from disk, it's slow and will severely
    affect your SSD life! You can optimize the order of configs to reduce the reading times
    by fixing k1 and k2 then vary k3 but I still don't recommend it

Nmesh: 1d array 
    Grid size. Three equal numbers are requested
    
BoxSize: 1d array
    Box size. Three equal numbers are requested

k_mode: 1d array 
    Length of the fundamental boxes in k-space
    $k_f = 2\pi/L$

Dk: float
    Width of the k-bin. Here we set Dk as integral multiple of k_mode

k_num: int
    Number of k_bins

k_center: 1d array
    Geometric centers of k_bins which can be used to calculate V_T analytically.
    Note that there is a small difference between geometric k-center and averaged k-center
    Here our default first k_center is 1.5*Dk(same as Hector),which means we 
    discard the first Dk-width kbin from the origin. 
    Other people(Changhoon or Roman) prefer to set k_center as integral multiple, please 
    modify relative parts in the code if you accept this convention.

k_edge: 1d array
    Edge of kbins. 
    k_edge[i] = k_center[i] - Dk/2, k_edge[i+1] = k_center[i] + Dk/2

dist_arr: 3d array
    Which denotes the distance from original points to each grid in k-space

mass_assignment: string
    pcs, cic, tsc (https://arxiv.org/abs/astro-ph/0409240v2)

index_range: list
    Batch processing, appoint the indexes of FKP_field or N_field need to be dealt with

FKP_source, N_source,Ylm_source, attrs_source,res_store_path: strings
    Paths to read or store files 

"""

# *************************************************************************************
settings_dict = numpy.load('settings.npy',allow_pickle=True).item()

silent = settings_dict["silent"] 
low_memory_mode = False
Nmesh = settings_dict["Nmesh"] 
BoxSize = settings_dict["BoxSize"] .astype("float64")
vol_per_cell = BoxSize.prod() / Nmesh.prod()  ## Physical volume of a cell in config-space
k_mode = 2 * numpy.pi / BoxSize
Dk =  settings_dict["number_of_kmode"] * k_mode[0]
k_num = settings_dict['k_num']
k_center = (numpy.arange(k_num) + 1.5) * Dk
k_edge = k_center - 0.5 * Dk
k_edge = numpy.append(k_edge, k_center[-1] + 0.5 * Dk)
mass_assignment = settings_dict['mass_assignment']
# index_range = settings_dict["index_range"] ## Be very carefull...
FKP_source = os.path.join(settings_dict['npy_store_path'],"FKP_fields")
N_source = os.path.join(settings_dict['npy_store_path'],"N_fields")
attrs_source = os.path.join(settings_dict['npy_store_path'],"attrs_stores")
# Ylm_source = os.path.join(os.getcwd(),"Y_lm_arrays") 
res_store_path = os.path.join(os.getcwd(), "Results")

# *************************************************************************************


# Some preparation
# =====================================================================================
coef_pi = (2 * numpy.pi) ** (3 + 3 + 3 - 3)  ## (2*pi) related to FFTs

## Load VT from disk
VT = numpy.loadtxt("VT_FFT.txt")

"""
Waring: 
If you are using a Mac, hidden files in the path like ".DS_Store" may trouble you 
and trigger a program error
Get the file list needed to be measured
"""
FKP_list = []
N_list = []
attrs_list = []

listdir(FKP_source, FKP_list, True)
listdir(N_source, N_list, True)
listdir(attrs_source, attrs_list, True)

FKP_list.sort()
N_list.sort()
attrs_list.sort()

# deleta file names contain ".DS_Store"
for X_list in [FKP_list, N_list, attrs_list]:
    for item in X_list: 
        if "Store" in item:
            X_list.remove(item)
        

# Create the result-storage path 
if os.path.exists(res_store_path):
    pass
else:
    os.mkdir(res_store_path)
if not silent:
    print("Result-storage path created")

## to store some information which may help get some insight of the running state of the program
count_path = os.path.join(os.getcwd(),"count")
if os.path.exists(count_path):
    pass
else:
    os.mkdir(count_path)

# Get the distance array in k-space for radial binning
dist_arr = get_k_dist(Nmesh, k_mode)
if not silent:
    print("Distance array in k-space has been generated")

"""
Create a ParticleMesh by loading the numpy.ndarray like FKP_field or N_field
generated by the preprocessing program
"""
my_PM = pm.ParticleMesh(BoxSize=BoxSize, Nmesh=Nmesh, dtype='c16')

# Compensation functions in k-space:
if mass_assignment == "pcs":
    cps = CompensatePCS
elif mass_assignment == "cic":
    cps = CompensateCIC
elif mass_assignment == "tsc":
    cps = CompensateTSC

## Full triangle configurations
sides = numpy.arange(k_num) + 1.5
config = []
count1 = 0
for i in sides:
    for j in sides:
        for k in sides:
            if i <= j and j <= k and k <= i + j - 1.50 and k >= j - i + 1.50:
                count1 += 1
                config.append([i, j, k])
if not silent:
    print("Number of configuration is ", count1)
    print("*"*50)


## Define a func to deal with binned shotnoise_field,
## return a list of shotnoise varys along k_center
def get_binned_noise(noise_field):
    binned_noise = []
    for i in range(k_num):
        chosen = numpy.logical_and(dist_arr >= k_edge[i], dist_arr < k_edge[i + 1])
        binned_noise.append(numpy.mean(noise_field[chosen]))
    return binned_noise


# Let's computing the Bis_est
# =====================================================================================
for s in range(0,len(FKP_list)):  # change it if necessary
    st = time.time()
    if not silent:
        print("Evaluating the full-configuration bispectrum monople \
              \n of %s "%(FKP_list[s]))

    ## Load some attrs from disk
    attrs_file = os.path.join(attrs_source, attrs_list[s])
    attrs = numpy.loadtxt(attrs_file)
    I33, S_00, norm, BoxCenter = attrs[1], attrs[2],attrs[3],attrs[4:]
    if not silent:
        print("Meta file loaded")


    ## Create the realfield Object(FKP_field), FFT and Compensate it 
    fkp_name = os.path.join(FKP_source, FKP_list[s])
    rfield = my_PM.create(type="real", value=numpy.load(fkp_name))
    F0 = rfield.r2c()
    F0.apply(out=Ellipsis, func=cps, kind="circular")
    if not silent:
        print("%s compensation to FKP_field applied"%(mass_assignment))
    
    ## Load N_field from disk, FFT and Compensate it 
    N_name = os.path.join(N_source, N_list[s])
    Nfield = my_PM.create(type="real", value=numpy.load(N_name))
    K_Nfield = Nfield.r2c() * norm
    K_Nfield.apply(out=Ellipsis, func=cps, kind="circular")
    if not silent:
        print("%s compensation to K_Nfield applied"%(mass_assignment))

    """
    FFT binned F0s to x-space
    Create a folder to store the binned FFTs of F0 in low_memory_mode
    We'd better delete them after all multipoles achieved
    """
    if not low_memory_mode:
        binned_x_F0 = []
        for i in range(k_num):
            chosen = numpy.logical_and(dist_arr >= k_edge[i], dist_arr < k_edge[i + 1])
            binned_F0 = F0.copy()
            binned_F0[~chosen] = 0
            binned_x_F0.append(numpy.array(binned_F0.c2r()))
    else:
        F0_path = './F0/'
        if os.path.exists(os.path.join(os.getcwd(), F0_path)):
            if not silent:
                print("F0-path already exists!")
        else:
            os.mkdir(os.path.join(os.getcwd(), F0_path))
            if not silent:
                print("F0-path created!")

        for i in range(k_num):
            chosen = numpy.logical_and(dist_arr >= k_edge[i], dist_arr < k_edge[i + 1])
            binned_F0 = F0.copy()
            binned_F0[~chosen] = 0
            to_store = numpy.array(binned_F0.c2r())
            numpy.save(F0_path + "%s_bin.npy" % i, to_store)
    
    if not silent:
        print("Time spent on getting binned F0-arrays is %s s" % (time.time() - st))
        print("*"*50)


    """
    Get Monopole
    Eq.53,54 in https://arxiv.org/abs/1506.02729
    """
    B_mono = []
    count = 0  # This only works for checking the multiply processing
    for xx in config:
        # get the index from side_length
        ind_0, ind_1, ind_2 = int(xx[0] - 1.5), int(xx[1] - 1.5), int(xx[2] - 1.5)  
        if not low_memory_mode:
            B_mono.append(numpy.sum(binned_x_F0[ind_0] * binned_x_F0[ind_1] * binned_x_F0[ind_2]))
        else:
            B_mono.append(numpy.sum(numpy.load(F0_path + "%s_bin.npy" % ind_0) * \
                                    numpy.load(F0_path + "%s_bin.npy" % ind_1) * numpy.load(
                F0_path + "%s_bin.npy" % ind_2)))
        count += 1
        if not silent:
            if count % 100 == 0:
                count_name = os.path.join(count_path,"Mono_count%s.txt"%count)
                numpy.savetxt(count_name, k_center)

    B_mono = coef_pi * vol_per_cell / (I33 * VT) * numpy.real(numpy.array(B_mono))
    numpy.savetxt(os.path.join(res_store_path, FKP_list[s]+"B_mono_full.txt"), B_mono)

    ## Shotnoise of B_monopole
    noise_field_B0 = (F0 * BoxSize.prod()) * numpy.conj(K_Nfield)
    binned_noise_B0 = get_binned_noise(noise_field_B0)

    B0_noise = []
    for xx in config:
        ind_0, ind_1, ind_2 = int(xx[0] - 1.5), int(xx[1] - 1.5), int(xx[2] - 1.5)
        B0_noise.append(binned_noise_B0[ind_0] + binned_noise_B0[ind_1] + binned_noise_B0[ind_2])
    B0_noise = (numpy.real(numpy.array(B0_noise)) - 2 * S_00) / I33
    numpy.savetxt(os.path.join(res_store_path, FKP_list[s]+"B0_noise_full.txt"), B0_noise)

    del noise_field_B0, Nfield, rfield
    gc.collect()

    if not silent:
        print("Time spent to complete the calculation of B0 is %s s" % (time.time() - st))

if low_memory_mode:
    shutil.rmtree(os.path.join(os.getcwd(), F0_path), True)
    if not silent:
        print("F0 fields have already been deleted from disk")