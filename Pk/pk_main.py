import numpy
import time
from nbodykit.lab import *
from nbodykit.source.mesh.catalog import CompensateTSC
import os
from funcs import get_k_dist, space_inversion
from pmesh import pm
import gc

"""
Parameter settings
"""
Nmesh = [512,512,512]
BoxSize = numpy.array([6900,6900,6900]).astype("float64")
kbin,kmin,kmax = 30,0,0.3
listrange=numpy.linspace(kmin,kmax,kbin+1)
k_mode = 2*numpy.pi/BoxSize
high_order = False ## whether evaluate P6,P8...

"""
    pathes to load FKP density field; Spherical harmonic field,
    some stored attribution data e.g., N0,alpha...
    as well as setting the path to store Pk multipole results
"""
FKP_source = os.path.join(os.getcwd(),"npy_stores")
Ylm_source = os.path.join(os.getcwd(),"Ylm_arrays")
attrs_source = os.path.join(os.getcwd(),"attrs_stores")
res_store_path = os.path.join(os.getcwd(),"results")

if os.path.exists(res_store_path):
    pass
else:
    os.mkdir(res_store_path)


"""
    getting the list of FKP density field to be dealt with and rank them 
"""
FKP_list = []
attrs_list = []
def listdir(path, list_name, iscontent):
    for file in os.listdir(path):
        file_path = os.path.join(path, file)
        if os.path.isdir(file_path):
            _isC = False
            if os.path.basename(file_path) == "TF":
                _isC = True
            listdir(file_path, list_name, _isC)
        else:
            if iscontent:
                list_name.append(file)
            # print(file_path)

listdir(FKP_source, FKP_list, True)
listdir(attrs_source, attrs_list, True)

FKP_list.sort()
attrs_list.sort()

## This may help you lot if you run this code on your Mac by deleting 
## annoying .DS_Store file which was generated by macOS.
for item in FKP_list:
    if "Store" in item:
        FKP_list.remove(item)
        break

for item in attrs_list:
    if "Store" in item:
        attrs_list.remove(item)
        break

print(FKP_list)
print(attrs_list)

# Get distance of every mesh grid to the mesh-center in k-space for radial binning
dist_arr = get_k_dist(Nmesh,k_mode) ## 

# Create a ParticleMesh object
my_PM = pm.ParticleMesh(BoxSize=BoxSize, Nmesh=Nmesh,dtype='c16')

"""
    Define a function get get F_ell by using space inversion algorithm
    we cut almost half of the FFTs
"""
def get_F_ell(ell):
    for m in range(0, ell + 1):
        weighted_field = rfield * numpy.load(os.path.join(Ylm_source, "Ylm_%s_%s_x_star.npy" % (ell, m)))
        weighted_field = weighted_field.r2c()
        weighted_field.apply(out=Ellipsis, func= CompensateTSC, kind="circular")
        weighted_field *= numpy.load(os.path.join(Ylm_source, "Ylm_%s_%s_k.npy" % (ell, m)))
        if m != 0:
            F_ell += weighted_field
            F_ell += numpy.conj(space_inversion(weighted_field))
            # Spatial inversion, although this step is not strictly correct in the specific operation 
            # (for example, the point at -N/2 has no inversion counterpart, but we do not need them)
        else:
            F_ell = weighted_field.copy()
    return F_ell * (BoxSize.prod() * 4*numpy.pi / (2*ell + 1)) 

"""
    Start to calculate P_ell(k), the main loop of "s" determined to how many FKP density fields need
    to be dealt with...
"""
for s in range(1):
    st = time.time()

    ## load some attrs like N0 or norm 
    attrs_path = os.path.join(attrs_source,attrs_list[s])
    attrs = numpy.loadtxt(attrs_path)
    norm = attrs[1]
    N0 = attrs[2]

    ## Creating an array to store results
    P = numpy.zeros((12,kbin)).astype("complex64")
    data_name = os.path.join(FKP_source, FKP_list[s])
    rfield = my_PM.create(type="real", value=numpy.load(data_name))
    
    cfield = rfield.r2c()
    cfield.apply(out=Ellipsis,func = CompensateTSC,kind = "circular")

    ## get F0($F_{0}(\mathbf{k})$)
    F0 = BoxSize.prod()* numpy.array(cfield)
    p0_field = F0 * numpy.conj(F0)

    P0 = []
    ## get effective k-center...
    if s == 0:
        k_eff = numpy.zeros(kbin)
        for i in range(kbin):
            chosen = numpy.logical_and(dist_arr>=listrange[i],dist_arr<listrange[i+1])            
            k_eff[i] = numpy.mean(dist_arr[chosen])
        numpy.savetxt("k_eff.txt",k_eff)

    for i in range(kbin):
        chosen = numpy.logical_and(dist_arr>=listrange[i],dist_arr<listrange[i+1])            
        P0.append(numpy.mean(p0_field[chosen]))

    P0 =numpy.array(P0)/norm-N0

    ## Reclaim memory
    del cfield, p0_field
    gc.collect()

    print("The time consumed to complete the calculation of P0 is %s s"%(time.time()-st))



    ## P2
    F2 = get_F_ell(2)
    p2_field = F0 * numpy.conj(F2)

    P2 = []
    for i in range(kbin):
        chosen = numpy.logical_and(dist_arr>=listrange[i],dist_arr<listrange[i+1])
        P2.append(numpy.mean(p2_field[chosen]))
    # print(P2)
    P2 = numpy.array(P2)*5/norm

    del p2_field
    gc.collect()

    print("The time consumed to complete the calculation of P2 is %s s"%(time.time()-st))


    ## P4b & P22
    p22_field = F2*numpy.conj(F2)
    P22 = []
    for i in range(kbin):
        chosen = numpy.logical_and(dist_arr>=listrange[i],dist_arr<listrange[i+1])
        P22.append(numpy.mean(p22_field[chosen]))

    P22 = numpy.array(P22)*9/norm - 9/5*N0
    P4b = 35/18 * P22 + (-7/2* P0-P2)

    del p22_field
    gc.collect()

    print("The time consumed to complete the calculation of P22 is %s s"%(time.time()-st))



    ## P4
    F4 = get_F_ell(4)
    p4_field = F0 * numpy.conj(F4)

    P4 = []
    for i in range(kbin):
        chosen = numpy.logical_and(dist_arr>=listrange[i],dist_arr<listrange[i+1])
        P4.append(numpy.mean(p4_field[chosen]))
    # print(P4)

    P4 = numpy.array(P4) * 9 /norm

    del p4_field
    gc.collect()

    print("The time consumed to complete the calculation of P4 is %s s"%(time.time()-st))


    if high_order:
        ## P6b & P42
        p42_field = F4*numpy.conj(F2)
        P42 = []
        for i in range(kbin):
            chosen = numpy.logical_and(dist_arr>=listrange[i],dist_arr<listrange[i+1])
            P42.append(numpy.mean(p42_field[chosen]))

        P42 = numpy.array(P42)*13/norm
        P6b = 11/5 * P42 + (-52/63*P4-286/175*P2)

        del p42_field,F2
        gc.collect()

        print("The time consumed to complete the calculation of P42 is %s s"%(time.time()-st))


        ## P6
        F6 = get_F_ell(6)
        p6_field = F0 * numpy.conj(F6)

        P6 = []
        for i in range(kbin):
            chosen = numpy.logical_and(dist_arr>=listrange[i],dist_arr<listrange[i+1])
            P6.append(numpy.mean(p6_field[chosen]))

        P6 = numpy.array(P6) * 13 /norm

        del p6_field, F6
        gc.collect()

        print("The time consumed to complete the calculation of P6 is %s s"%(time.time()-st))


        ## P8b & P44
        p44_field = F4*numpy.conj(F4)
        P44 = []
        for i in range(kbin):
            chosen = numpy.logical_and(dist_arr>=listrange[i],dist_arr<listrange[i+1])
            P44.append(numpy.mean(p44_field[chosen]))

        P44 = numpy.array(P44)*17/norm - 17/9*N0
        P8b = 1287/490 * P44 + (-374/245*P42-3553/15435*P4-1326/8575*P2-2431/490*P0)

        del p44_field,F4
        gc.collect()

        print("The time consumed to complete the calculation of P44 is %s s"%(time.time()-st))



        ## P8
        F8 = get_F_ell(8)
        p8_field = F0 * numpy.conj(F8)

        P8 = []
        for i in range(kbin):
            chosen = numpy.logical_and(dist_arr>=listrange[i],dist_arr<listrange[i+1])
            P8.append(numpy.mean(p8_field[chosen]))

        P8 = numpy.array(P8) * 17 /norm

        del p8_field, F8, rfield
        gc.collect()

        print("The time consumed to complete the calculation of P8 is %s s"%(time.time()-st))


    ## save multipoles to disk
    P[0] = P0
    P[1] = P2
    P[2] = P22
    P[3] = P4b
    P[4] = P4
    if high_order:
        P[5] = P42
        P[6] = P6b
        P[7] = P6
        P[8] = P44
        P[9] = P8b
        P[10] = P8
    
    f_name = FKP_list[s].replace("FKP_field","")
    f_name = f_name.replace(".dat.npy","")
    res_name = "P"+f_name+".txt"
    numpy.savetxt(os.path.join(res_store_path,res_name),P)

    et = time.time()
    print("Computation time for %s is %s s"%(f_name,et-st))
